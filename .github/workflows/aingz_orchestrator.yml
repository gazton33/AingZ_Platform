# ---
# file: .github/workflows/aingz_orchestrator.yml
# code: ORCH
# name: AingZ_Orchestrator_V4
# version: v4.0
# date: 2025-08-10
# owner: AingZ_Platform · RwB
# status: active
# xrf:
#   blueprint: RwB_Blueprint_V4
#   mplan: RwB_MasterPlan_V4
#   glossary: CODE_Glossary_v2
#   dictionary: CODE_Triggers_v2
# triggers: [TRG_CONSOLIDATE_TL]
# chg: CHG_main.md#orch_v4
# chk: CHK_root.md#orch_v4
# ---

name: "AingZ Orchestrator V4"

on:
  workflow_dispatch:
    inputs:
      reason:
        description: "Motivo de ejecución (p.ej. orchestrate-v4)"
        required: false
        default: orchestrate-v4

permissions:
  actions: write
  contents: write
  pull-requests: write

concurrency:
  group: orchestrator-${{ github.ref }}
  cancel-in-progress: false

env:
  ORCH_REASON: ${{ github.event.inputs.reason || 'orchestrate-v4' }}

jobs:
  preflight:
    name: "Preflight · validación mínima"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: List workflows (debug)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const res = await github.rest.actions.listRepoWorkflows({ owner, repo });
            core.info(`Workflows detectados: ${res.data.workflows.map(w=>`${w.name} -> ${w.path}`).join('\n')}`);

      - name: Verificar presencia de workflows requeridos
        uses: actions/github-script@v7
        with:
          script: |
            const required = [
              '.github/workflows/aingz_tallado_readmes.yml',
              '.github/workflows/aingz_crossref_fix.yml',
              '.github/workflows/aingz_harvest_knowledge.yml',
              '.github/workflows/aingz_incoherence_report.yml',
              '.github/workflows/aingz_purge_fixes_v2.yml'
            ];
            const { owner, repo } = context.repo;
            const { data } = await github.rest.actions.listRepoWorkflows({ owner, repo });
            const paths = new Set(data.workflows.map(w=>w.path));
            const missing = required.filter(p => !paths.has(p));
            if (missing.length) {
              core.setFailed(`Faltan workflows requeridos o están deshabilitados: \n${missing.join('\n')}\n` +
                             `Asegurá que existan y tengan 'on: workflow_dispatch'.`);
            } else {
              core.info('OK · Todos los workflows requeridos existen.');
            }

  orchestrate:
    name: "Orchestrate · encadenar WFs (dispatch + wait)"
    needs: preflight
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Encadenar workflows
        id: chain
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const ref = context.ref.replace('refs/heads/','');
            const reason = process.env.ORCH_REASON || 'orchestrate-v4';

            const chain = [
              '.github/workflows/aingz_tallado_readmes.yml',
              '.github/workflows/aingz_crossref_fix.yml',
              '.github/workflows/aingz_harvest_knowledge.yml',
              '.github/workflows/aingz_incoherence_report.yml',
              '.github/workflows/aingz_purge_fixes_v2.yml'
            ];

            async function findWorkflowIdByPath(path) {
              const { data } = await github.rest.actions.listRepoWorkflows({ owner, repo });
              const wf = data.workflows.find(w => w.path === path);
              return wf ? wf.id : null;
            }

            async function dispatch(wfId) {
              await github.rest.actions.createWorkflowDispatch({
                owner, repo, workflow_id: wfId, ref,
                inputs: { reason }
              });
            }

            async function waitForRun(wfId) {
              const start = Date.now();
              const timeoutMs = 60 * 60 * 1000; // 60 min
              const sleep = ms => new Promise(r => setTimeout(r, ms));

              let runId = null;
              // Espera a que aparezca un run
              while (Date.now() - start < timeoutMs) {
                const { data } = await github.rest.actions.listWorkflowRuns({ owner, repo, workflow_id: wfId, branch: ref, per_page: 10 });
                const run = data.workflow_runs.find(r => r.head_branch === ref);
                if (run) { runId = run.id; break; }
                await sleep(5000);
              }
              if (!runId) core.setFailed('Timeout esperando inicio de run');

              // Espera a la finalización
              while (Date.now() - start < timeoutMs) {
                const { data } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
                core.info(`Estado: ${data.name} -> ${data.status}/${data.conclusion || ''}`);
                if (data.status === 'completed') {
                  if (data.conclusion !== 'success') {
                    core.setFailed(`Concluyó con estado: ${data.conclusion}`);
                  }
                  return;
                }
                await sleep(15000);
              }
              core.setFailed('Timeout esperando finalización de run');
            }

            for (const path of chain) {
              const wfId = await findWorkflowIdByPath(path);
              if (!wfId) core.setFailed(`Workflow no encontrado: ${path}`);
              core.info(`Dispatch → ${path} @ ${ref} (reason=${reason})`);
              await dispatch(wfId);
              await waitForRun(wfId);
            }

      - name: Resultado
        if: always()
        run: |
          echo "Motivo: $ORCH_REASON"
          echo "Cadena completada (ver historial en Actions)."

# ---
# OutputTemplate (obligatorio / comentado para GH Actions)
# output_example:
#   status: OK
#   id_asset: orch_v4
#   generated_by: ai
#   created_at: 2025-08-10T00:00:00-03:00
#   params:
#     - reason: orchestrate-v4
#   result:
#     - chain:
#       - aingz_tallado_readmes.yml
#       - aingz_crossref_fix.yml
#       - aingz_harvest_knowledge.yml
#       - aingz_incoherence_report.yml
#       - aingz_purge_fixes_v2.yml
#   log:
#     - step1: preflight check
#     - step2: dispatch chain
#     - step3: wait & validate
