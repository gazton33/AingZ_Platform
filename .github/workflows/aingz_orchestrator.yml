# ---
# file: .github/workflows/aingz_orchestrator.yml
# code: ORCH
# name: AingZ_Orchestrator_V4
# version: v4.0
# date: 2025-08-10
# owner: AingZ_Platform · RwB
# status: active
# xrf:
#   blueprint: RwB_Blueprint_V4
#   mplan: RwB_MasterPlan_V4
#   glossary: CODE_Glossary_v2
#   dictionary: CODE_Triggers_v2
# triggers: [TRG_CONSOLIDATE_TL]
# chg: CHG_main.md#orch_v4
# chk: CHK_root.md#orch_v4
# ---

name: "AingZ Orchestrator V4"

on:
  workflow_dispatch:
    inputs:
      reason:
        description: "Motivo de ejecución (p.ej. orchestrate-v4)"
        required: false
        default: orchestrate-v4

permissions:
  actions: write
  contents: write
  pull-requests: write

concurrency:
  group: orchestrator-${{ github.ref }}
  cancel-in-progress: false

env:
  ORCH_REASON: ${{ github.event.inputs.reason || 'orchestrate-v4' }}

jobs:
  preflight:
    name: "Preflight · detección y validación mínima"
    runs-on: ubuntu-latest
    outputs:
      purge_path: ${{ steps.scan.outputs.purge_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: List workflows (debug)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const res = await github.rest.actions.listRepoWorkflows({ owner, repo });
            core.info(`Workflows detectados (name → path):\n` + res.data.workflows.map(w=>`${w.name} → ${w.path}`).join('\n'));

      - name: Verificar presencia de workflows requeridos (tolerante purge v2/v_2)
        id: scan
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const reqFixed = [
              '.github/workflows/aingz_tallado_readmes.yml',
              '.github/workflows/aingz_crossref_fix.yml',
              '.github/workflows/aingz_harvest_knowledge.yml',
              '.github/workflows/aingz_incoherence_report.yml'
            ];
            const purgeCandidates = [
              '.github/workflows/aingz_purge_fixes_v2.yml',
            ];
            const { data } = await github.rest.actions.listRepoWorkflows({ owner, repo });
            const paths = new Set(data.workflows.map(w=>w.path));

            const missing = reqFixed.filter(p => !paths.has(p));
            let purge_path = purgeCandidates.find(p => paths.has(p));
            if (!purge_path) missing.push(purgeCandidates.join(' | '));

            if (missing.length) {
              core.setFailed(`Faltan workflows requeridos o con nombre distinto:\n${missing.join('\n')}\n` +
                             `Sugerencia: mantener el nombre canónico o ajustar el orquestador.`);
            } else {
              core.info(`OK · Todos los workflows requeridos presentes. purge_path=${purge_path}`);
              core.setOutput('purge_path', purge_path);
            }

  orchestrate:
    name: "Orchestrate · dispatch + wait"
    needs: preflight
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Encadenar workflows (espera a finalización)
        id: chain
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const branch = context.ref.replace('refs/heads/','');
            const reason = process.env.ORCH_REASON || 'orchestrate-v4';
            const purgePath = ${{ toJSON(needs.preflight.outputs.purge_path) }}; // path resultante del preflight

            const chain = [
              '.github/workflows/aingz_tallado_readmes.yml',
              '.github/workflows/aingz_crossref_fix.yml',
              '.github/workflows/aingz_harvest_knowledge.yml',
              '.github/workflows/aingz_incoherence_report.yml',
              (purgePath || '').replace(/^"|"$/g, '')
            ];

            async function findWorkflowIdByPath(path) {
              const { data } = await github.rest.actions.listRepoWorkflows({ owner, repo });
              const wf = data.workflows.find(w => w.path === path);
              return wf ? wf.id : null;
            }

            async function dispatch(wfId) {
              await github.rest.actions.createWorkflowDispatch({
                owner, repo, workflow_id: wfId, ref: branch,
                inputs: { reason }
              });
            }

            async function waitForRun(wfId, startedAt) {
              const timeoutMs = 60 * 60 * 1000; // 60 min
              const sleep = ms => new Promise(r => setTimeout(r, ms));
              const isAfter = (a, b) => new Date(a).getTime() >= new Date(b).getTime();

              let runId = null;
              const start = Date.now();

              // Espera a que aparezca un run nuevo
              while (Date.now() - start < timeoutMs) {
                const { data } = await github.rest.actions.listWorkflowRuns({ owner, repo, workflow_id: wfId, branch, per_page: 20 });
                const run = data.workflow_runs.find(r => r.head_branch === branch && isAfter(r.created_at, startedAt));
                if (run) { runId = run.id; break; }
                await sleep(5000);
              }
              if (!runId) core.setFailed('Timeout esperando inicio del run');

              // Espera a la finalización
              while (Date.now() - start < timeoutMs) {
                const { data } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
                core.info(`Estado: ${data.name} -> ${data.status}/${data.conclusion || ''}`);
                if (data.status === 'completed') {
                  if (data.conclusion !== 'success') core.setFailed(`Concluyó con estado: ${data.conclusion}`);
                  return;
                }
                await sleep(15000);
              }
              core.setFailed('Timeout esperando finalización del run');
            }

            for (const path of chain) {
              const wfId = await findWorkflowIdByPath(path);
              if (!wfId) core.setFailed(`Workflow no encontrado: ${path}`);
              const startedAt = new Date().toISOString();
              core.info(`Dispatch → ${path} @ ${branch} (reason=${reason})`);
              await dispatch(wfId);
              await waitForRun(wfId, startedAt);
            }

      - name: Resultado
        if: always()
        run: |
          echo "Motivo: $ORCH_REASON"
          echo "Cadena completada (ver historial en Actions)."

# ---
# OutputTemplate (obligatorio / comentado para GH Actions)
# output_example:
#   status: OK
#   id_asset: orch_v4
#   generated_by: ai
#   created_at: 2025-08-10T00:00:00-03:00
#   params:
#     - reason: orchestrate-v4
#   result:
#     - chain:
#       - aingz_tallado_readmes.yml
#       - aingz_crossref_fix.yml
#       - aingz_harvest_knowledge.yml
#       - aingz_incoherence_report.yml
#       - aingz_purge_fixes_v2.yml | aingz_purge_fixes_v_2.yml
#   log:
#     - step1: preflight check
#     - step2: dispatch chain
#     - step3: wait & validate
